import cv2
import numpy as np

from typing import List, Optional


from ulc_mm_package.hardware.scope import MalariaScope
from ulc_mm_package.neural_nets.YOGOInference import YOGO
from ulc_mm_package.neural_nets.neural_network_constants import IMG_RESIZED_DIMS
from ulc_mm_package.image_processing.processing_constants import (
    RBC_THUMBNAIL_PATH,
    CELLS_FOUND_THRESHOLD,
    MIN_CELL_COUNT,
)

RBC_THUMBNAIL = cv2.imread(RBC_THUMBNAIL_PATH, 0)


def downsample_image(img: np.ndarray, scale_factor: int) -> np.ndarray:
    """Downsamples an image by `scale_factor`"""

    h, w = img.shape
    return cv2.resize(img, (w // scale_factor, h // scale_factor))


def get_correlation_map(
    img: np.ndarray,
    template_img: np.ndarray = RBC_THUMBNAIL,
    downsample_factor: int = 20,
) -> np.ndarray:
    """Downsamples the image and returns the 2D cross-correlation map.

    Side note
    ----------
    The values generated by the cross-correlation map (using TM_CCOEFF)
    are sensitive to the dimensions of the image and template. As such, the threshold
    used is somewhat specific to the particular downsampling factor used.

    TM_CCOEFF_NORMED (which normalizes the values to lie within 0-1) is not used
    because we want to do a comparison of how well the template matches _between_ images.

    This function has been tested for robustness with a downsample_factor=10
    and the current template image (image_processing/thumbnail.png).

    Parameters
    ----------
    img: np.ndarray
        Base image
    template_img: np.ndarray
        Image to use as a template for the cross-correlation
    downsample_factor: int=10

    Returns
    -------
    np.ndarray:
        Map of the 2D cross-correlation values
    """

    img_ds = downsample_image(img, downsample_factor)
    return cv2.matchTemplate(img_ds, template_img, cv2.TM_CCOEFF)


class LowDensity(Exception):
    pass


class NoCellsFound(Exception):
    pass


class CellFinder:
    def __init__(
        self, template_path: str = RBC_THUMBNAIL_PATH, downsample_factor: int = 10
    ):
        self.thumbnail = downsample_image(
            cv2.imread(template_path, 0), downsample_factor
        )
        self.downsample_factor = downsample_factor
        self.motor_pos: List[int] = []
        self.xcorr_coeffs: List[float] = []
        self.cell_counts: List[int] = []

    def add_image(self, motor_pos: int, img: np.ndarray) -> None:
        """Check for cells for the given image, store the result + motor position the image was taken at."""

        self.motor_pos.append(motor_pos)
        xcorr_map = get_correlation_map(img, self.thumbnail, self.downsample_factor)
        self.xcorr_coeffs.append(np.max(xcorr_map))

    def add_image(self, mscope: MalariaScope, img: np.ndarray) -> None:
        """Check for cells for the given image, store the result + motor position the image was taken at.

        Stores both the cross correlation result and the number of healthy cells detected via YOGO.
        """
        res = mscope.cell_diagnosis_model.syn(cv2.resize(img, IMG_RESIZED_DIMS))
        num_healthy_cells = YOGO.class_instance_count(YOGO.filter_res(res[0]))[0]
        xcorr_map = get_correlation_map(img, self.thumbnail, self.downsample_factor)

        self.cell_counts.append(num_healthy_cells)
        self.motor_pos.append(mscope.motor.pos)
        self.xcorr_coeffs.append(np.max(xcorr_map))

    def get_cells_found_position(self) -> Optional[int]:
        """Check if the cross-correlation value exceeds the threshold for cell detection and there are
        a sufficient number of cells present.

        Returns
        -------
        int
            Motor position if cells were found
        Exceptions
        ----------
        NoCellsFound
            Raised if the value of the maximum cross correlation value from the given images
            does not exceed a threshold.
        """

        argmax = np.argmax(self.xcorr_coeffs)
        max_val = self.xcorr_coeffs[argmax]

        if (
            max_val >= CELLS_FOUND_THRESHOLD
            and self.cell_counts[argmax] > MIN_CELL_COUNT
        ):
            return self.motor_pos[np.argmax(self.xcorr_coeffs)]

        raise NoCellsFound(
            "None of the images at any of the motor positions had a maximum cross-correlation exceeding the CELLS_FOUND threshold"
        )

    def reset(self) -> None:
        self.motor_pos = []
        self.xcorr_coeffs = []
        self.cell_counts = []

    def find_cells_cross_corr(self, img: np.ndarray) -> float:
        """Returns the max value of the correlation between the RBC thumbnail and the given image (downsampled)

        Returns
        -------
        float:
            Max value of the 2D cross-correlation
        """

        cross_corr_map = get_correlation_map(
            img, self.thumbnail, self.downsample_factor
        )
        return np.max(cross_corr_map)
