import numpy as np
import cv2
from ulc_mm_package.image_processing.processing_constants import (
    RBC_THUMBNAIL_PATH,
    CELLS_FOUND_THRESHOLD,
    MIN_CELL_COUNT,
)


def downsample_image(img: np.ndarray, scale_factor: int) -> np.ndarray:
    """Downsamples an image by `scale_factor`"""

    h, w = img.shape
    return cv2.resize(img, (w // scale_factor, h // scale_factor))


def get_correlation_map(
    template_img: np.ndarray, img: np.ndarray, downsample_factor: int = 10
) -> np.ndarray:
    """Downsamples the image and returns the 2D cross-correlation map.

    Side note
    ----------
    The values generated by the cross-correlation map (using TM_CCOEFF)
    are sensitive to the dimensions of the image and template. As such, the threshold
    used is somewhat specific to the particular downsampling factor used.

    TM_CCOEFF_NORMED (which normalizes the values to lie within 0-1) is not used
    because we want to do a comparison of how well the template matches _between_ images.

    This function has been tested for robustness with a downsample_factor=10
    and the current template image (image_processing/thumbnail.png).

    Parameters
    ----------
    template_img: np.ndarray
        Image to use as a template for the cross-correlation
    img: np.ndarray
        Base image
    downsample_factor: int=10

    Returns
    -------
    np.ndarray:
        Map of the 2D cross-correlation values
    """

    img_ds = downsample_image(img, downsample_factor)
    return cv2.matchTemplate(img_ds, template_img, cv2.TM_CCOEFF)


def count_cells(img: np.ndarray, downsample_factor: int = 4) -> int:
    """Count the number of cells using a basic binarizing+connected-components analysis.

    Parameters
    ----------
    img: np.ndarray
    downsample_factor: int

    Returns
    -------
    int:
        The number of bounding boxes found
    """

    ds_img = downsample_image(img, downsample_factor)
    th = cv2.adaptiveThreshold(
        ds_img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 5, 10
    )
    _, _, boxes, _ = cv2.connectedComponentsWithStats(th)

    return len(
        boxes[1:]
    )  # First bbox is the background, so we exclude and return the reset


def isDensitySufficient(img, downsample_factor: int = 4) -> bool:
    """Check whether the cell count is sufficently high"""
    return count_cells(img, downsample_factor) >= MIN_CELL_COUNT


class NoCellsFound(Exception):
    pass


class CellFinder:
    def __init__(
        self, template_path: str = RBC_THUMBNAIL_PATH, downsample_factor: int = 10
    ):
        self.thumbnail = downsample_image(
            cv2.imread(template_path, 0), downsample_factor
        )
        self.downsample_factor = downsample_factor
        self.motor_pos = []
        self.confidences = []

    def add_image(self, motor_pos: int, img: np.ndarray) -> None:
        """Check for cells for the given image, store the result + motor position the image was taken at."""

        self.motor_pos.append(motor_pos)
        self.confidences.append(count_cells(img))

    def get_cells_found_position(self):
        """Check if the cross-correlation value exceeds the threshold for cell detection."""

        max_val = np.max(self.confidences)
        if max_val >= MIN_CELL_COUNT:
            return self.motor_pos[np.argmax(self.confidences)]
        else:
            raise NoCellsFound(
                "None of the images at any of the motor positions had a maximum cross-correlation exceeding the CELLS_FOUND threshold"
            )

    def reset(self):
        self.motor_pos = []
        self.confidences = []

    def find_cells_cross_corr(self, img: np.ndarray) -> float:
        """Returns the max value of the correlation between the RBC thumbnail and the given image (downsampled)

        Returns
        -------
        float:
            Max value of the 2D cross-correlation
        """

        cross_corr_map = get_correlation_map(
            self.thumbnail, img, self.downsample_factor
        )
        return np.max(cross_corr_map)
